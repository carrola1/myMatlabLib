function [i_code, q_code] = myGenTdrssRtnLnkMode2(userCode,zeroOne)
% Designer:     Andrew Carroll
%
% Description:  Generate TDRSS return link mode 2 PN codes (return from TDRSS perspective)
%
% Inputs:       userCode  : Select User Code 1-85
%               upsamp    : # of pts per chip
%               zeroOne   : 0 = min bit 0, 1 = min bit -1
%
% Outputs       i_code    : I channel short code out
%               q_code    : Q channel short code out

%%

% TDRSS Return Link Command Channel Initial Conditions Register A and Register C
% User Codes 1 - 85 (From STDN No. 1)

IcRegA_Arr = {  '00000000100'; '00000100000'; '00001000000'; '00010000000'; '00010100000'; '01000000100';...
                '10000001000'; '00001000100'; '10101010010'; '01010100100'; '10100100000'; '01001000000';...
                '11010000011'; '00000111001'; '00001110010'; '00011100100'; '00111001000'; '01110010001';...
                '00011011101'; '00110111010'; '01101110101'; '11101011101'; '11010111010'; '01110101000';...
                '10000101000'; '10100010010'; '01000100100'; '10001001000'; '00100010101'; '01000101011';...
                '00101011010'; '10000100111'; '00001001111'; '01001111001'; '11100111001'; '11100101111';...
                '11001011110'; '11110111001'; '11101110010'; '10010010101'; '10101110110'; '11000010101';...
                '01010111001'; '10101110010'; '01011100100'; '00001011101'; '10111010010'; '10100110110';...
                '00110110001'; '01101100011'; '11011000111'; '10110001111'; '01100011110'; '11101110110';...
                '11011101100'; '10111011001'; '11001010101'; '01010101111'; '10111100000'; '01011111001';...
                '10111110010'; '11110010010'; '11100100100'; '11001001000'; '10010010001'; '00100100011';...
                '00111011010'; '01110110101'; '11101101011'; '01101011010'; '11010110101'; '10101101011';...
                '01011010110'; '11010110001'; '11000110001'; '10001100011'; '00011101111'; '00111011110';...
                '01111011010'; '10101001011'; '01010010110'; '01100001100'; '10011100111'; '11001111110';...
                '11111101111' }; 
              
IcRegC_Arr = {  '00000000110'; '00000110000'; '00001100000'; '00011000000'; '00011110000'; '11100000110';...
                '11000001100'; '00001100110'; '11111111011'; '11111110110'; '11110110000'; '11101100000';...
                '10111000010'; '10000100101'; '00001001011'; '00010010110'; '00100101100'; '01001011001';...
                '10010110011'; '00101100111'; '01011001111'; '10011110011'; '00111100111'; '11001111100';...
                '11000111100'; '11110011011'; '11100110110'; '11001101100'; '10110011111'; '01100111110';...
                '00111110111'; '01000110100'; '10001101000'; '01101000101'; '10010100101'; '10010111000';...
                '00101110001'; '10001100101'; '00011001011'; '01011011111'; '11111001101'; '10100011111';...
                '01111100101'; '11111001011'; '11110010110'; '10001110011'; '11100111011'; '11110101101';...
                '10101101001'; '01011010010'; '10110100100'; '01101001000'; '11010010001'; '00011001101';...
                '00110011010'; '01100110101'; '10101111111'; '01111111000'; '11100010000'; '01110000101';...
                '11100001011'; '00001011011'; '00010110110'; '00101101100'; '01011011001'; '10110110010';...
                '00100110111'; '01001101111'; '10011011110'; '11011110111'; '10111101111'; '01111011110';...
                '11110111101'; '10111101001'; '10100101001'; '01001010010'; '10010011000'; '00100110001';...
                '11000110111'; '01111101110'; '11111011101'; '11010001010'; '01010010100'; '00101000001';...
                '10000011000' };


reg_A = myBin2Dec(char(IcRegA_Arr(userCode)),0,11,0,0);
reg_A = myDec2Bin(reg_A,0,11,0,0);

reg_B = [0 0 0 0 0 0 0 0 0 0 1];    % Fixed

reg_C = myBin2Dec(char(IcRegC_Arr(userCode)),0,11,0,0);
reg_C = myDec2Bin(reg_C,0,11,0,0);
            

i_code = zeros(1,2^11-1);
q_code = zeros(1,2^11-1);
for ii = 1:2^11-1
  
  % Outputs
  i_code(ii) = mod(reg_A(end)+reg_B(end),2);
  q_code(ii) = mod(reg_B(end)+reg_C(end),2);
  if zeroOne == 1
    if i_code(ii) == 0
      i_code(ii) = -1;
    end
    if q_code(ii) == 0
      q_code(ii) = -1;
    end
  end
  
  % Shift reg inputs
  new_A = mod(sum(reg_A([2 11])),2);
  new_B = mod(sum(reg_B([2 5 8 11])),2);
  new_C = mod(sum(reg_C([2 11])),2);
  
  % Update registers
  reg_A = [new_A reg_A(1:end-1)];
  reg_B = [new_B reg_B(1:end-1)];
  reg_C = [new_C reg_C(1:end-1)];
end

end
 
 
 
 
 
 
 
 
 
 
    